import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { filterByStatus } from '../serverList/ServerStatus';
import { fetchInstanceData } from '../serverList/ServerAPI';

const initialState = {
  config: {
    serverDefaultTootThreshold: 5000, // Default value for Servers
    peering: {
      minUserCount: 5000, // Minimum User count for a Server to be added id using "add peers".
      minTootCount: 1000, // Minimum Toot count for a Server to be added id using "add peers".
      repeerTimeout: 168, // in minutes = 7 days.
      blacklist: ['activitypub-troll.cf'],
    },
    serverFilter: {
      status: ['new', 'active'],
      orderBy: 'domain_count',
    },
    trendsFilter: {
      minToots: 100,
      minUrls: 2,
      maxTotal: 2,
    },
    minRefreshTime: {
      // Time to wait before requesting update from server.
      instance: 1000 * 60 * 120, // 120min 7200000
      trends: 1000 * 60 * 120, // 120min
    },
  },
  servers: {
    'https://social.donkeymedia.u': {
      url: 'https://social.donkeymedia.u',
      status: 'new', //[new, active, disabled, unreachable, error, blacklisted] @see ServerStatus::getStatus()
      instance: null, // /api/v1/instance
      trends: [], // /api/v1/trends/tags
      peers: [],
      minTootThreshold: -1, // -1 use Global, >-1 = value,
    },
    'https://mastodon.social': {
      url: 'https://mastodon.social',
      status: 'new',
      instance: null,
      trends: [],
      peers: [],
      minTootThreshold: -1, // -1 use Global, >-1 = value,
    },
    'https://mstdn.social': {
      url: 'https://mstdn.social',
      status: 'new',
      instance: null,
      trends: [],
      peers: [],
      minTootThreshold: -1, // -1 use Global, >-1 = value,
    },
    'https://mstdn.science': {
      url: 'https://mstdn.science',
      status: 'new',
      instance: null,
      trends: [],
      peers: [],
      minTootThreshold: -1, // -1 use Global, >-1 = value,
    },
    'https://chaos.social': {
      url: 'https://chaos.social',
      status: 'new',
      instance: null,
      trends: [],
      peers: [],
      minTootThreshold: -1, // -1 use Global, >-1 = value,
    },
    'https://infosec.exchange': {
      url: 'https://infosec.exchange',
      status: 'new',
      instance: null,
      trends: [],
      peers: [],
      minTootThreshold: -1, // -1 use Global, >-1 = value,
    },
  },
  trends: {},
};



export const myniverse = createSlice({
  name: 'myniverse',
  initialState,
  reducers: {
    addServer: (state, action) => {
      state.servers[action.payload.url] = action.payload;
    },
    deleteServer: (state, action) => {
      delete state.servers[action.payload.url];
    },
    deleteTrend: (state, action) => {
      delete state.trends[action.payload.toLowerCase()];
    },
    updateServerMinTootThreshold: (state, action) => {
      state.servers[action.payload.url].minTootThreshold =
        action.payload.minTootThreshold;
    },
    updateConfig: (state, action) => {
      state.config = { ...state.config, ...action.payload };
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(updateinstanceInfo.fulfilled, (state, action) => {
      state.servers = {
        ...state.servers,
        [action.payload.url]: {
          ...action.payload,
        },
      };
    });

    builder.addCase(getServerTrends.fulfilled, (state, action) => {
      state.servers = {
        ...state.servers,
        [action.payload.url]: {
          ...state.servers[action.payload.url],
          lastUpdateTrends: action.payload.lastUpdate,
          status: ['unreachable', 'error'].includes(action.payload.status) ? 'no-trends' : action.payload.status,
          trends: action.payload.trends,
        },
      };
    });

    builder.addCase(updateGlobalTrend.fulfilled, (state, action) => {
      if (action.payload) {
        state.trends = {
          ...state.trends,
          [action.payload.name.toLowerCase()]: action.payload,
        };
      }
    });
  },
});

export const {
  addServer,
  deleteServer,
  updateServerMinTootThreshold,
  updateConfig,
  deleteTrend,
} = myniverse.actions;

// SYNC

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const addServerByUri = (url) => (dispatch, getState) => {
  const servers = getServerObjects(getState());
  if (!servers || !servers[url]) {
    const newServer = getServerDefault(url);
    dispatch(addServer(newServer));
    dispatch(updateinstanceInfo(newServer));
  }
  else {
    console.info(`Allready in list: ${url}`);
  }
};

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const updateServerUri = (url, newUrl) => (dispatch, getState) => {
  const servers = getServerObjects(getState());
  // Add new Server if not in list
  if (!servers || !servers[newUrl]) {
    dispatch(deleteServer({ url: url }));
    dispatch(addServer(getServerDefault(newUrl)));
    dispatch(updateinstanceInfo(getServerDefault(newUrl)));
  }
  else {
    console.info(`Server allready in list: ${newUrl}`);
  }
};

export const forceUpdateInstanceInfo = (server) => (dispatch, getState) => {
  delete server.lastUpdate;
  dispatch(updateinstanceInfo(server));
};

// ASYNC

export const updateGlobalTrend = createAsyncThunk(
  'myniverse/updateGlobalTrend',
  async (args, thunkAPI) => {
    const { trend, serverUrl } = args;
    let prevTrend =
      thunkAPI.getState().myniverse.trends[trend.name.toLowerCase()];
    let newTrend = { ...trend };

    if (prevTrend && prevTrend.history[0].day < trend.history[0].day) {
      // Drop outdated and dispatch update.
      prevTrend = false;
      const urlsList = makeArray(prevTrend.urls);
      const servers = getServerObjects(thunkAPI.getState())
      urlsList.forEach((url) => {
        if (servers && servers[url.serverUrl]) {
          thunkAPI.dispatch(getServerTrends(servers[url.serverUrl]))
        }
      });
    }

    // Aggregate data
    if (prevTrend) {
      // Reaggregating?
      const trendUrlInStorrage = prevTrend.urls[serverUrl];
      if (trendUrlInStorrage) {
        console.info('Trend is allready aggregated.');
        newTrend = null;
      }
      else {
        // Aggregate values
        // console.info(`Aggregating ${trend}.`); // BREAKS DEVTOOLS.

        newTrend.history = newTrend.history.map((hist, i) => {
          return {
            ...hist,
            accounts:
              parseInt(hist.accounts) + parseInt(prevTrend.history[i].accounts),
            uses: parseInt(hist.uses) + parseInt(prevTrend.history[i].uses),
          };
        });
        // Aggregate Urls
        newTrend.urls = {
          ...prevTrend.urls,
          [serverUrl]: {
            serverUrl: serverUrl,
            url: trend.url,
          },
        };
        delete newTrend.url;
      }
    }

    // Create new Trend in store.
    if (!prevTrend) {
      newTrend.urls = {};
      newTrend.urls[serverUrl] = {
        serverUrl: serverUrl,
        url: trend.url,
      };
      delete newTrend.url;
    }

    if (!newTrend.urls) {
      console.error('SOMETHING WRONG HERE');
    }
    return newTrend;
  },
);

export const getServerTrends = createAsyncThunk(
  'myniverse/getServerTrends',
  async (server, thunkAPI) => {
    const { minRefreshTime } = getConfig(thunkAPI.getState());
    const now = new Date().valueOf();
    const fetchNew = ['no-trends'].includes(server.status) || !server.trends || !server.lastUpdateTrends || server.lastUpdateTrends + minRefreshTime.trends < now;
    if (fetchNew) {
      const trends = await fetchInstanceData(server.url, 'trends');
      if (trends.trends) {
        trends.trends.forEach((t) => {
          thunkAPI.dispatch(
            updateGlobalTrend({
              trend: t,
              serverUrl: server.url,
            }),
          );
        });
      }
      // If there are no trends public this disables the server,
      // by applying fetch result status to server status.
      return { ...server, ...trends };
    }
    return { ...server };
  },
);

export const addPeerInstances = createAsyncThunk(
  'myniverse/addPeerInstances',
  async (url, thunkAPI) => {
    const serverList = await fetchInstanceData(url, 'peers');
    const {
      peering,
      minRefreshTime,
    } = getConfig(thunkAPI.getState());
    if (serverList.status === 'active') {
      return Promise.all(
        serverList.peers.map(async (domain) => {

          if (peering.blacklist.some((v) => domain.includes(v))) {
            thunkAPI.rejectWithValue(`Domain ${domain} blacklisted`);
          }
          else {

            const servers = getServerList(thunkAPI.getState());
            const instanceUrl = `https://${domain}`;
            const prevInstance = servers[instanceUrl] ? servers[instanceUrl] : getServerDefault(instanceUrl)
            const now = new Date().valueOf();

            // Respect timeouts before re-fetch.
            if (
              !prevInstance.lastUpdate ||
              prevInstance.lastUpdate <= now + minRefreshTime.instance ||
              (prevInstance.status =
                'disabled' &&
                prevInstance.lastUpdate <= now + peering.repeerTimeout * 60 * 60) // Minutes to millisecond.
            ) {
              const server = await fetchInstanceData(instanceUrl, 'instance');
              if (
                server.status === 'active' &&
                server.instance &&
                server.instance.stats.user_count >= peering.minUserCount &&
                server.instance.stats.status_count >= peering.minTootCount
              ) {
                thunkAPI.dispatch(
                  updateinstanceInfo({ ...prevInstance, ...server }),
                );
              }
              else {
                // Non-active instances stored status='disabled' to reduce refetching..
                thunkAPI.dispatch(
                  updateinstanceInfo({
                    ...prevInstance,
                    ...server,
                    ...{ status: 'disabled' },
                  }),
                );
              }
            }
            else {
              console.info(
                `${
                  prevInstance.url
                } is up to date. Min refresh time is set to ${
                  minRefreshTime.instance / 1000 / 60
                }min.`,
              );
            }
          }
        }),
      );
    }
    return null;
  },
);

const updateinstanceInfo = createAsyncThunk(
  'myniverse/updateinstanceInfo',
  async (server, thunkAPI) => {
    const { minRefreshTime } = getConfig(thunkAPI.getState());
    const now = new Date().valueOf();
    let instance = {};

    if (
      !server.lastUpdate ||
      server.lastUpdate + minRefreshTime.instance < now
    ) {
      instance = await fetchInstanceData(server.url, 'instance');
    }
    else {
      console.info(
        `${server.url} is up to date. Min refresh time is set to ${
          minRefreshTime.instance / 1000 / 60
        }min.`,
      );
    }
    const updated = { ...server, ...instance }
    if (updated.status === 'active') {
      thunkAPI.dispatch(getServerTrends(server));
    }
    return updated;
  },
);

export const deleteOldTrends = createAsyncThunk(
  'myniverse/deleteOldTrends',
  async (server, thunkAPI) => {
    const trends = getTrendsList(thunkAPI.getState());
    // Drop 24h old trends.
    if (trends.length) {
      return Promise.all(
        trends.map(async (trend) => {
          const twentyFourHours = new Date();
          twentyFourHours.setDate(twentyFourHours.getDate() - 1);
          //console.log(`${trend.history[0].day * 1000} <= ${twentyFourHours.valueOf()}`, trend.history[0].day * 1000 <= twentyFourHours.valueOf())
          if (trend.history[0].day * 1000 <= twentyFourHours.valueOf()) {
            console.info(`Deleting #${trend.name}`);
            return thunkAPI.dispatch(deleteTrend(trend.name))
          }
          return null;
        })
      )
    }
    return null;
  },
);

export const updateAllTrends = createAsyncThunk(
  'myniverse/updateAllTrends',
  async (server, thunkAPI) => {
    thunkAPI.dispatch(deleteOldTrends());
    const servers = getServerList(thunkAPI.getState());
    if (servers.length) {
      return Promise.all(
        servers.map(async (server) => {
          if (server.status === 'active') {
            return thunkAPI.dispatch(getServerTrends(server));
          }
          return null;
        })
      )
    }
    return null;
  },
);

export const updateInstancesByStatus = createAsyncThunk(
  'myniverse/updateInstancesByStatus',
  async (status, thunkAPI) => {
    const update = filterByStatus(getServerList(thunkAPI.getState()), status)
    if (update.length) {
      return Promise.all(
        update.map(async (server) => {
          thunkAPI.dispatch(updateinstanceInfo(server));
        })
      )
    }
    return null;
  },
);

// Selectors
// can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const getConfig = (state) => state.myniverse.config;

export const getTrendsList = (state) => {
  return makeArray(state.myniverse.trends);
};

export const getServerList = (state) => {
  return makeArray(state.myniverse.servers);
};

export const getServerObjects = (state) => {
  return state.myniverse.servers;
};

// Defaults
// Assuming to have at least one default with any url in `initialState.servers`.
const getServerDefault = (url) => {
  return {
    ...initialState.servers[Object.keys(initialState.servers)[0]],
    ...{ url: url },
  };
};

// Helper
// Turns Objects as stored into iterable arrays.
export const makeArray = (obj) => {
  return Object.keys(obj).map((x) => obj[x]);
};

export default myniverse.reducer;
